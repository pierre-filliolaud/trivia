<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Event sourcing / CQRS : live coding</title>

		<meta name="description" content="Support aux speakers pour la présentation">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css" id="theme">
		<link rel="stylesheet" href="css/live-coding.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-speaker="">
					<h2>Bienvenue</h2>
					<ul>
						<li>Démarche : présentation des concepts event sourcing / CQRS par du code</li>
						<li>Attention : c'est un live coding</li>
					</ul>
				</section>
				<section data-speaker="">
					<h2>Plan</h2>
					<h3>1. Event sourcing</h3>
					<ol>
						<li>Comment on va voir émerger <em>naturellement</em> les évènements du système</li>
						<li>Comment on va découvrir les fonctionnalités utiles d'un <em>event store</em></li>
					</ol>
				</section>
				<section data-speaker="">
					<h2>Plan</h2>
					<h3>2. CQRS</h3>
					<ol>
						<li>Pourquoi découper son système en commandes et en queries</li>
						<li>Comment découper son système et commandes et en queries</li>
						<li>Pourquoi CQRS s'adapte extrèmement bien à l'event sourcing</li>
					</ol>
				</section>
				<section data-speaker="">
					<h2>Plan</h2>
					<h3>3. Stratégies de rejeu</h3>
					<ol>
						<li>Comment l'event sourcing vous permet de rejouer le passé</li>
						<li>Quels sont les intérêts de pouvoir rejouer les évènements immuables du passé</li>
					</ol>
				</section>
				<section data-speaker="">
					<h2>Préambule</h2>
					<h3>Notre cas d'étude</h3>
					<ul>
						<li>Connaissez-vous les katas de refactoring ?</li>
						<li>Trivia : du code <em>dégeu</em> <span class="action">montrer <code>Game</code></span></li>
					</ul>
				</section>
				<section data-speaker="">
					<h2>Préambule</h2>
					<h3>Notre cas d'étude</h3>
					<ul>
						<li>Principe du jeu :
							<ol>
								<li>des joueurs</li>
								<li>des questions dans des catégories</li>
								<li>un plateau</li>
								<li>un dé</li>
								<li>un maître du jeu</li>
								<li>une prison</li>
							</ol>
						</li>
						<li>Cinématique <span class="action">montrer <code>GameRunner</code></span></li>
					</ul>
				</section>
				<section data-speaker="">
					<h2>Préambule</h2>
					<h3>Notre cas d'étude</h3>
					<p>On va commencer le kata ensemble en écrivant des tests</p>
					<p>C'est là normalement que vous vous demandez si vous vous ne vous êtes pas trompés de salle</p>
					<p>On vous confirme : c'est bien un live coding sur Event sourcing / CQRS</p>
					<p>Un peu de patience : vous allez comprendre</p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - events</h2>
					<p class="action">Aller dans <code>GameTest</code></p>
					<p class="action">Tester la fonctionalité d'ajout d'un joueur : <code>should_add_one_player()</code></p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - events</h2>
					<pre><code data-trim>
assertThat(result).isTrue()
assertThat(game.howManyPlayers()).isEqualTo(1)
					</code></pre>
					<p>Pas suffisant pour être sûr que le nom du joueur est bien pris en compte</p>
					<p class="action">Lancer le test</p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - events</h2>
					<p>Oh regarde : il y a des sorties dans la console</p>
					<p>Ça serait pas des évènements par hasard ?</p>
					<pre><code data-trim>
assertThat(eventStore.events()).containsExactly(
    new PlayerWasAdded("seb"),
    new PlayersCount(1));
					</code></pre>
					<p class="action">Implémenter <code>PlayerWasAdded</code> et <code>PlayersCount</code></p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - events</h2>
					<p>Ajout de <code>@Rule EventStore</code></p>
					<p>Fonction <code>String -> Event</code> à implémenter dans <code>Event</code></p>
					<p><code>static Event fromLine(String line)</code></p>
					<p><code>return UnknownEvent();</code></p>
					<p class="fail">Ça fail</p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - events</h2>
					<p>Implémenter <code>static Event fromLine(String line)</code> avec des regexp</p>
					<p class="success">Ça passe</p>
				</section>
				<section data-speaker="">
					<h2>1 - ES</h2>
					<p><strong>Transition</strong> : nous allons découvrir quelques fonctionnalités d'un event store à partir des tests.</p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - start</h2>
					<p class="action">dupliquer le test précédent en <code>should_add_two_players</code></p>
					<p class="action">ajouter <code>game.add("Pierre-Jean")</code></p>
					<p class="action">ajouter les assertions seulement sur</p>
					<ul>
						<li><code>Pierre-Jean</code></li>
						<li><em>count</em> à 2</li>
					</ul>
					<p class="fail">ça fail</p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - start</h2>
					<p><code>EventStore</code> doit enregistrer les évènements quand <strong>je</strong> le décide</p>
					<p class="action">ajouter <code>game.start()</code></p>
					<p class="success">ça passe</p>
					<p class="action">aller voir l'implem</p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - filtre</h2>
					<p>On veut parfois ne s'intéresser qu'à un seul type d'events</p>
					<p class="action">dupliquer le test précédent en <code>should_add_players_with_same_name</code></p>
					<p class="action">ajouter deux fois <code>"Pierre-Jean"</code></p>
					<p class="action">asserter seulement <code>PlayerWasAdded</code></p>
					<p>c'est plus lisible pour le test</p>
					<p class="fail">ça fail</p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - filtre</h2>
					<p><code>eventStore.events(PlayerWasAdded.class)</code></p>
					<p style="color: green">ça passe</p>
					<p>aller voir l'implem</p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - proc</h2>
					<p>Oh là là c'est embêtant toutes ces sorties dans la console</p>
					<p>Comment on clean un peu tout ça ?</p>
					<p>ajouter <code>eventStore.debug()</code> au début du test</p>
					<p style="color: red">ça compile pas</p>
				</section>
				<section data-speaker="">
					<h2>1 - ES - proc</h2>
					<p>créer la méthode dans <code>EventStore</code></p>
					<p>expliquer les processeurs</p>
					<p>bouger l'initialisation des 2 processeurs existants dans <code>debug()</code></p>
					<pre><code>
preProcessors.add(line -> console.format("%50s -> ", line));
postProcessors.add(console::println);
					</code></pre>
					<p style="color: green">ça compile et on ne voit que les logs qui nous intéressent</p>
				</section>
				<section data-speaker="">
					<h2>1 &rarr; 2</h2>
					<p>il y a plein d'autres fonctionnalités dans un <code>EventStore</code></p>
					<p>on va s'arrêter là</p>
					<p><strong>Résumé</strong> : c'est quoi l'EventStore ?</p>
					<p>c'est la base de l'event sourcing</p>
					<p>un système de persistance d'évènements immuables et chronologiques</p>
				</section>
				<section data-speaker="">
					<h2>1 &rarr; 2</h2>
					<p>on vous avait promis CQRS</p>
					<p>découvrons les concepts par du code</p>
				</section>
				<section data-speaker="">
					<h2>2 - CQRS - Segreg.</h2>
					<blockquote>&ldquo;Command Query Responsability Segregation&rdquo;</blockquote>
					<p>on va grave ségreger</p>
					<p>créer les interfaces <code>Commands</code> et <code>Queries</code></p>
					<p><code>Game</code> les implémente</p>
					<p>parcourir les méthodes (noms et implem)</p>
					<p>choisir dans quelle interface ça matche</p>
				</section>
				<section data-speaker="">
					<h2>2 - CQRS - Segreg.</h2>
					<p>On doit arriver à ça</p>
					<pre><code>
Commands
 boolean add(String)
 void roll(int)
 boolean wasCorrectlyAnswered()
 boolean wrongAnswer()
Queries
 boolean isPlayable()
 int howManyPlayers()
					</code></pre>
				</section>
				<section data-speaker="">
					<h2>2 - CQRS - Segreg.</h2>
					<h3>Commands</h3>
					<p class="action">Aller dans l'interface <code>Commands</code></p>
					<p>Sur les commandes, on peut juste remarquer qu'elles ne sont pas toutes <code>void</code></p>
					<p>Généralement on préfère faire du <em>fire and forget</em> et être asynchrone sur les commandes</p>
					<p>Prendre l'exemple de <code>add</code> qui retourne toujours <code>true</code> !</p>
				</section>
				<section data-speaker="">
					<h2>2 - CQRS - Segreg.</h2>
					<h3>Queries</h3>
					<p class="action">Aller dans l'interface <code>Queries</code></p>
					<p class="action">Montrer les usages de <code>isPlayable()</code></p>
					<p>Utilisé que dans les tests : c'est du code mort</p>
					<p class="action">Supprimer <code>isPlayable</code> et ses usages</p>
				</section>
				<section data-speaker="">
					<h2>2 - CQRS - Segreg.</h2>
					<h3>Queries</h3>
					<p class="action">Revenir sur l'interface <code>Queries</code></p>
					<p class="action">Montrer les usages de <code>howManyPlayers()</code></p>
					<p>C'est une méthode privée</p>
					<p class="action">Supprimer <code>howManyPlayers()</code></p>
				</section>
				<section data-speaker="">
					<h2>2 - CQRS - Segreg.</h2>
					<h3>Queries</h3>
					<p class="action">Revenir sur l'interface <code>Queries</code></p>
					<p>Il n'y a pas de <em>queries</em> dans <code>Game</code></p>
					<p>C'est une implémentation du circuit d'écriture du système</p>
				</section>
				<section data-speaker="">
					<h2>2 - CQRS - Segreg.</h2>
					<h3>Queries</h3>
					<p>Nouveau scénario : notre jeu a du succès. Beaucoup de succès.</p>
					<p>Notre PO nous demande d'implémenter un service web qui permet de récupérer à tout moment l'état du jeu</p>
				</section>
				<section data-markdown>
					<script type="text/template">
						notre PO nous décrit maintenant une nouvelle story : le jeu commence à avoir du succès et de plus en plus de joueurs
						aimeraient se connecter au jeu en cours pour pouvoir l'observer. Nous allons donc écrire un nouveau composant qui va
						effectuer cette tâche en s'abonnant aux évènements émits par le circuit d'écriture et recréer un état quand cela est
						nécessaire. Nous sauvegarderons l'état en JSON dans un fichier plat qui sera servi par un serveur web frontal.

						## Étape 3 ##
						Partir du client graphique et montrer le mode rejoue des évènements depuis le début vs récupère l'état courant du jeu.
					</script>
				</section>

				<section>
					<h3>Speaker View</h3>
					<p>There's a <a href="https://github.com/hakimel/reveal.js#speaker-notes">speaker view</a>. It includes a timer, preview of the upcoming slide as well as your speaker notes.</p>
					<p>Press the <em>S</em> key to try it out.</p>

					<aside class="notes">
						Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the speaker notes window (hit 's' on your keyboard).
					</aside>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
			
			function background(speaker) {
				section.removeAttribute('data-speaker');
				section.setAttribute('data-background', 'assets/' + speaker + '.jpg');
				section.setAttribute('data-background-repeat', 'no-repeat');
				section.setAttribute('data-background-size', '48pt');
				section.setAttribute('data-background-position', 'top left');
			}

			var sections = document.getElementsByTagName('section');
			var previousSpeaker = 'sebastian';
			for (var i = 0; i < sections.length; i++) {
				var section = sections.item(i);
				if (section.hasAttribute('data-speaker')) {
					var currentSpeaker = section.getAttribute('data-speaker') ? currentSpeaker = section.getAttribute('data-speaker') : (previousSpeaker === 'sebastian' ? 'pierre-jean' : 'sebastian');
					previousSpeaker = currentSpeaker;
					background(currentSpeaker);
				}
			}
		</script>

	</body>
</html>
